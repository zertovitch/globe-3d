--  Warning: This lexical scanner is automatically generated by AFLEX.
--  *******   It is useless to modify it. Change the ".Y" & ".L" files instead.
with Text_IO; use Text_IO;
with md5_dfa; use md5_dfa;
with md5_io; use md5_io;
--# line 1 "md5.l"
--------------------------------------------------------------------------
--  MD5.l
--
--  MD5 mesh / anim grammar file (AFLEX)
--
--  Copyright (c) Gautier de Montmollin 2017
--  SWITZERLAND
--
--  Permission is hereby granted, free of charge, to any person obtaining a copy
--  of this software and associated documentation files (the "Software"), to deal
--  in the Software without restriction, including without limitation the rights
--  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
--  copies of the Software, and to permit persons to whom the Software is
--  furnished to do so, subject to the following conditions:
--  The above copyright notice and this permission notice shall be included in
--  all copies or substantial portions of the Software.
--  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
--  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
--  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
--  THE SOFTWARE.
-- NB: this is the MIT License, as found 28-Jul-2008 on the site
-- http://www.opensource.org/licenses/mit-license.php
--------------------------------------------------------------------------
--
-- Change log:
--
-- xx-yyy-2017 GdM: Created
--
--# line 50 "md5.l"


with MD5_Tokens; use MD5_Tokens;
with MD5_Help;   use MD5_Help;

function YYLex return Token is

subtype Short is Integer range -32768 .. 32767;
    yy_act : Integer;
    yy_c   : Short;

-- returned upon end-of-file
YY_END_TOK : constant Integer := 0;
YY_END_OF_BUFFER : constant := 54;
subtype yy_state_type is Integer;
yy_current_state : yy_state_type;
INITIAL : constant := 0;
yy_accept : constant array(0..255) of Short :=
    (   0,
       45,   45,   54,   53,   50,   51,   53,   53,    7,    8,
        4,   45,   45,   53,   42,   43,   53,   49,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
        5,    3,    6,   50,    0,   47,    0,    0,    0,    0,
        0,   45,   45,   43,    0,   45,    0,    0,   44,    0,
       43,    0,   48,   49,   49,   49,   49,    0,   45,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
       49,    0,    0,    0,    0,    0,    0,    0,   45,    0,
        0,    0,    2,   44,   46,   49,   49,   49,   49,   49,
       49,   49,   49,   49,   10,   49,   49,   30,   49,   49,

       49,    0,    0,    0,    0,    0,   13,    0,    0,    0,
        0,    0,    0,    1,   46,   49,   49,   49,   49,   49,
       49,   49,   49,   25,   49,   49,   49,   49,   49,   49,
       49,   49,   40,   28,   49,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   49,   49,   49,   41,   39,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
       49,    0,    0,   17,    0,   16,    0,    0,    0,    0,
        0,    0,   49,   37,   49,   49,   49,   24,   49,   49,
       49,   49,   49,   49,   49,   49,   27,   32,    0,    0,
       18,    0,   13,    0,    0,    0,    0,   12,   49,   49,

       49,   49,   49,   49,   49,   49,   49,   29,   49,   49,
        0,   11,    0,   13,    9,    0,   19,   49,   49,   49,
       49,   49,   49,   49,   49,   49,   26,   49,   38,   49,
       34,   36,   49,   49,   33,   22,   23,   49,   49,   20,
       49,   31,   21,   49,   49,   49,   49,   49,   49,   49,
       49,   49,   49,   35,    0
    ) ;

yy_ec : constant array (ASCII.NUL..Character'Last) of Short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    1,    1,    1,    1,    6,
        7,    8,    9,   10,   11,   12,   13,   14,   15,   15,
       15,   15,   16,   15,   15,   17,   17,    1,    1,   18,
        1,   19,    1,    1,   21,   22,   23,   24,   25,   26,
       27,   28,   29,   30,   20,   31,   32,   33,   34,   35,
       20,   36,   37,   38,   39,   40,   41,   42,   43,   20,
        1,    1,    1,    1,   20,    1,   21,   22,   23,   24,

       25,   26,   27,   28,   29,   30,   20,   31,   32,   33,
       34,   35,   20,   36,   37,   38,   39,   40,   41,   42,
       43,   20,   44,   45,   46,    1,    1, others=> 1

    ) ;

yy_meta : constant array (0 ..46) of Short :=
    (   0,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    1,    4,    4,    4,    4,    1,    1,    3,
        4,    4,    4,    4,    4,    4,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    1,    1,    1
    ) ;

yy_base : constant array(0..271) of Short :=
    (   0,
        0,    0,  408,  409,  405,  409,  402,   23,  409,  409,
      409,   39,   51,   61,   65,   71,  386,    0,   29,  370,
       83,   36,  374,  368,   35,   36,  373,  364,  374,  373,
      409,  409,  409,  395,  392,  391,  369,   40,   58,  357,
      359,   87,   94,  101,  113,  117,  383,  387,  123,    0,
      129,  370,  409,    0,  351,  348,  354,  135,  141,  354,
      363,  358,  353,  365,  343,  341,  346,  356,   66,  340,
      346,  348,  124,  349,   90,  349,  350,  346,  148,  361,
      112,  365,  409,  154,  336,  341,  332,  332,  326,  330,
      325,  327,  319,  330,    0,  159,  333,    0,  331,  317,

      327,  324,  326,  326,  321,  346,  409,  156,  164,  317,
      320,  321,  337,  409,  409,  318,  319,  321,  316,  315,
      318,  300,  312,    0,  303,  299,  300,  308,  296,  306,
      305,  304,    0,    0,  300,  294,  323,  322,  298,  157,
      169,  284,  290,  295,  284,  282,  285,    0,  281,  280,
      278,  278,  284,  291,  282,  273,  280,  272,  278,  270,
      267,  279,  300,  409,  299,  409,  298,  297,  170,  275,
      277,  294,  275,    0,  271,  273,  270,    0,  255,  259,
      258,  256,  260,  250,  248,  258,    0,    0,  281,  280,
      409,  279,  409,  278,  255,  276,  275,  409,  245,  245,

      237,  246,  244,  251,  246,  232,  244,    0,  231,  239,
      263,  409,  262,  409,  409,  261,  409,  238,  233,  236,
      217,  225,  164,  161,  158,  156,    0,  154,    0,  157,
        0,    0,  154,  161,    0,    0,    0,  147,  157,    0,
      154,    0,    0,  154,  142,  143,  139,  113,  103,   96,
       56,   40,   24,    0,  409,  200,  204,  206,  210,  214,
       45,  218,  222,  226,  230,  234,  238,  242,  246,  250,
      254
    ) ;

yy_def : constant array (0 ..271) of Short :=
    (   0,
      255,    1,  255,  255,  255,  255,  256,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  257,  258,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
      255,  255,  255,  255,  256,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  259,  260,  255,  261,
      255,  257,  255,  258,  258,  258,  258,  255,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
      258,  255,  255,  255,  262,  255,  255,  255,  255,  259,
      263,  260,  255,  255,  261,  258,  258,  258,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,

      258,  255,  255,  255,  255,  262,  255,  262,  262,  255,
      255,  255,  259,  255,  255,  258,  258,  258,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
      258,  258,  258,  258,  258,  255,  264,  265,  255,  262,
      262,  255,  255,  255,  258,  258,  258,  258,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
      258,  255,  264,  255,  265,  255,  266,  267,  262,  255,
      255,  268,  258,  258,  258,  258,  258,  258,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  269,  266,
      255,  267,  255,  270,  255,  271,  268,  255,  258,  258,

      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
      269,  255,  270,  255,  255,  271,  255,  258,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
      258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
      258,  258,  258,  258,    0,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255
    ) ;

yy_nxt : constant array (0 ..455) of Short :=
    (   0,
        4,    5,    6,    7,    8,    9,   10,    4,    4,   11,
       12,   13,   14,   15,   16,   16,   16,   17,    4,   18,
       18,   19,   20,   18,   21,   22,   18,   23,   18,   24,
       18,   25,   26,   18,   18,   18,   27,   28,   18,   29,
       30,   18,   18,   31,   32,   33,   37,   38,   85,   55,
       42,   39,   43,   44,   44,   44,   60,   40,   64,   65,
      254,   41,   56,   45,   46,   46,   46,   46,   47,   66,
       73,   61,   74,   48,   67,   45,   42,  253,   43,   49,
       49,   43,   42,   75,   51,   51,   51,   51,  252,   45,
       76,   58,  107,   58,   98,   45,   59,   59,   59,   59,

       46,   46,   46,   46,   99,   42,   50,   43,   43,   43,
       43,   45,   42,  108,   51,   51,   51,   51,   45,   81,
      251,   58,  109,   58,  114,   45,   79,   79,   79,   79,
       46,   46,   46,   46,   42,  250,   84,   84,   84,   43,
       42,   45,   51,   51,   51,   51,  249,   45,   79,   79,
       79,   79,  103,   45,   59,   59,   59,   59,  107,  107,
      104,   79,   79,   79,   79,   42,  107,   84,   84,   84,
       43,  107,  107,  248,  247,  246,  245,  244,   45,  125,
      140,  243,  168,  242,  126,  241,  240,  141,  127,  239,
      128,  238,  237,  169,  236,  194,  129,  235,  130,  131,

       35,  234,   35,   35,   52,   52,   52,   52,   54,   54,
       80,   80,   80,   80,   82,   82,   82,   82,  106,  106,
      106,  106,  113,  113,  113,  113,  163,  163,  163,  163,
      165,  165,  165,  165,  190,  190,  190,  190,  192,  192,
      192,  192,  197,  197,  197,  197,  211,  211,  211,  211,
      213,  213,  213,  213,  216,  216,  216,  216,  233,  232,
      231,  230,  229,  217,  214,  212,  228,  227,  226,  225,
      224,  223,  222,  221,  220,  219,  218,  198,  217,  215,
      214,  193,  191,  212,  210,  209,  208,  207,  206,  205,
      204,  203,  202,  201,  200,  199,  198,  196,  195,  193,

      191,  166,  164,  189,  188,  187,  186,  185,  184,  183,
      182,  181,  180,  179,  178,  177,  176,  175,  174,  173,
      172,  171,  170,  167,  166,  164,  162,  161,  160,  159,
      158,  157,  156,  155,  154,  153,  152,  151,  150,  149,
      148,  147,  146,  145,   81,  144,  143,  142,  107,  139,
      138,  137,  136,  135,  134,  133,  132,  124,  123,  122,
      121,  120,  119,  118,  117,  116,  115,   83,   81,  112,
      111,  110,  105,  102,  101,  100,   97,   96,   95,   94,
       93,   92,   91,   90,   89,   88,   87,   86,   53,   83,
       81,   78,   77,   72,   35,   36,   34,   71,   70,   69,

       68,   63,   62,   57,   53,   36,   34,  255,    3,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255
    ) ;

yy_chk : constant array (0 ..455) of Short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    8,    8,  261,   19,
       12,    8,   12,   12,   12,   12,   22,    8,   25,   25,
      253,    8,   19,   12,   13,   13,   13,   13,   14,   26,
       38,   22,   38,   14,   26,   13,   15,  252,   15,   15,
       15,   15,   16,   39,   16,   16,   16,   16,  251,   15,
       39,   21,   75,   21,   69,   16,   21,   21,   21,   21,

       42,   42,   42,   42,   69,   43,   15,   43,   43,   43,
       43,   42,   44,   75,   44,   44,   44,   44,   43,   81,
      250,   45,   75,   45,   81,   44,   45,   45,   45,   45,
       46,   46,   46,   46,   49,  249,   49,   49,   49,   49,
       51,   46,   51,   51,   51,   51,  248,   49,   58,   58,
       58,   58,   73,   51,   59,   59,   59,   59,  108,  140,
       73,   79,   79,   79,   79,   84,  109,   84,   84,   84,
       84,  141,  169,  247,  246,  245,  244,  241,   84,   96,
      108,  239,  140,  238,   96,  234,  233,  109,   96,  230,
       96,  228,  226,  141,  225,  169,   96,  224,   96,   96,

      256,  223,  256,  256,  257,  257,  257,  257,  258,  258,
      259,  259,  259,  259,  260,  260,  260,  260,  262,  262,
      262,  262,  263,  263,  263,  263,  264,  264,  264,  264,
      265,  265,  265,  265,  266,  266,  266,  266,  267,  267,
      267,  267,  268,  268,  268,  268,  269,  269,  269,  269,
      270,  270,  270,  270,  271,  271,  271,  271,  222,  221,
      220,  219,  218,  216,  213,  211,  210,  209,  207,  206,
      205,  204,  203,  202,  201,  200,  199,  197,  196,  195,
      194,  192,  190,  189,  186,  185,  184,  183,  182,  181,
      180,  179,  177,  176,  175,  173,  172,  171,  170,  168,

      167,  165,  163,  162,  161,  160,  159,  158,  157,  156,
      155,  154,  153,  152,  151,  150,  149,  147,  146,  145,
      144,  143,  142,  139,  138,  137,  136,  135,  132,  131,
      130,  129,  128,  127,  126,  125,  123,  122,  121,  120,
      119,  118,  117,  116,  113,  112,  111,  110,  106,  105,
      104,  103,  102,  101,  100,   99,   97,   94,   93,   92,
       91,   90,   89,   88,   87,   86,   85,   82,   80,   78,
       77,   76,   74,   72,   71,   70,   68,   67,   66,   65,
       64,   63,   62,   61,   60,   57,   56,   55,   52,   48,
       47,   41,   40,   37,   36,   35,   34,   30,   29,   28,

       27,   24,   23,   20,   17,    7,    5,    3,  255,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
      255,  255,  255,  255,  255
    ) ;

  --  Copy whatever the last rule matched to the standard output

  procedure ECHO is
  begin
    if Text_IO.Is_Open (user_output_file) then
      Text_IO.Put ( user_output_file, YYText );
    else
      Text_IO.Put ( YYText );
    end if;
  end ECHO;

  --  enter a start condition.
  --  Using procedure requires a () after the ENTER, but makes everything
  --  much neater.

  procedure ENTER ( state : Integer ) is
  begin
    yy_start := 1 + 2 * state;
  end ENTER;

  -- action number for EOF rule of a given start state
  function YY_STATE_EOF (state : Integer) return Integer is
  begin
    return YY_END_OF_BUFFER + state + 1;
  end YY_STATE_EOF;

  -- return all but the first 'n' matched characters back to the input stream
  procedure yyless (n : Integer) is
  begin
    yy_ch_buf(yy_cp) := yy_hold_char;  --  undo effects of setting up yytext
    yy_cp := yy_bp + n;
    yy_c_buf_p := yy_cp;
    YY_DO_BEFORE_ACTION;  --  set up yytext again
  end yyless;

  -- redefine this if you have something you want each time.
  procedure YY_USER_ACTION is
  begin
    null;
  end YY_USER_ACTION;

  --  yy_get_previous_state - get the state just before the EOB char was reached

  function yy_get_previous_state return yy_state_type is
    yy_current_state : yy_state_type;
    yy_c : Short;
begin
    yy_current_state := yy_start;

    for yy_cp in yytext_ptr..yy_c_buf_p - 1 loop
        yy_c := yy_ec(yy_ch_buf(yy_cp));
        if yy_accept(yy_current_state) /= 0 then
            yy_last_accepting_state := yy_current_state;
            yy_last_accepting_cpos := yy_cp;
        end if;
        while yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state loop
            yy_current_state := yy_def(yy_current_state);
            if yy_current_state >= 256 then
                yy_c := yy_meta(yy_c);
            end if;
        end loop;
        yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
    end loop;

    return yy_current_state;
  end yy_get_previous_state;

  procedure yyrestart( input_file : File_Type ) is
  begin
    Open_Input (Text_IO.Name (input_file));
  end yyrestart;

begin  --  of YYLex
<<new_file>>
        --  This is where we enter upon encountering an end-of-file and
        --  yyWrap() indicating that we should continue processing

    if yy_init then
        if yy_start = 0 then
          yy_start := 1;      --  first start state
        end if;

        --  We put in the '\n' and start reading from [1] so that an
        --  initial match-at-newline will be true.

        yy_ch_buf(0) := ASCII.LF;
        yy_n_chars := 1;

        --  We always need two end-of-buffer characters. The first causes
        --  a transition to the end-of-buffer state. The second causes
        --  a jam in that state.

        yy_ch_buf(yy_n_chars) := YY_END_OF_BUFFER_CHAR;
        yy_ch_buf(yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

        yy_eof_has_been_seen := False;

        yytext_ptr := 1;
        yy_c_buf_p := yytext_ptr;
        yy_hold_char := yy_ch_buf(yy_c_buf_p);
        yy_init := False;
-- UMASS CODES :
--   Initialization
        tok_begin_line := 1;
        tok_end_line   := 1;
        tok_begin_col := 0;
        tok_end_col   := 0;
        token_at_end_of_line := False;
        line_number_of_saved_tok_line1 := 0;
        line_number_of_saved_tok_line2 := 0;
-- END OF UMASS CODES.
    end if;  --  yy_init

    loop                -- loops until end-of-file is reached

-- UMASS CODES :
--    if last matched token is end_of_line, we must
--    update the token_end_line and reset tok_end_col.
    if Token_At_End_Of_Line then
      Tok_End_Line := Tok_End_Line + 1;
      Tok_End_Col := 0;
      Token_At_End_Of_Line := False;
    end if;
-- END OF UMASS CODES.

        yy_cp := yy_c_buf_p;

        -- support of yytext
        yy_ch_buf(yy_cp) := yy_hold_char;

        -- yy_bp points to the position in yy_ch_buf of the start of the
        -- current run.
        yy_bp := yy_cp;
        yy_current_state := yy_start;
        loop
                yy_c := yy_ec(yy_ch_buf(yy_cp));
                if yy_accept(yy_current_state) /= 0 then
                    yy_last_accepting_state := yy_current_state;
                    yy_last_accepting_cpos := yy_cp;
                end if;
                while yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state loop
                    yy_current_state := yy_def(yy_current_state);
                    if yy_current_state >= 256 then
                        yy_c := yy_meta(yy_c);
                    end if;
                end loop;
                yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
            yy_cp := yy_cp + 1;
if yy_current_state = 255 then
    exit;
end if;
        end loop;
        yy_cp := yy_last_accepting_cpos;
        yy_current_state := yy_last_accepting_state;

<<next_action>>
            yy_act := yy_accept(yy_current_state);
            YY_DO_BEFORE_ACTION;
            YY_USER_ACTION;

        if aflex_debug then  --  Output acceptance info. for (-d) debug mode
            Text_IO.Put (Standard_Error, "--accepting rule #");
            Text_IO.Put (Standard_Error, Integer'Image (yy_act));
            Text_IO.Put_Line (Standard_Error, "(""" & YYText & """)");
        end if;

-- UMASS CODES :
--   Update tok_begin_line, tok_end_line, tok_begin_col and tok_end_col
--   after matching the token.
        if yy_act /= YY_END_OF_BUFFER and then yy_act /= 0 then
-- Token are matched only when yy_act is not yy_end_of_buffer or 0.
          Tok_Begin_Line := Tok_End_Line;
          Tok_Begin_Col := Tok_End_Col + 1;
          Tok_End_Col := Tok_Begin_Col + yy_cp - yy_bp - 1;
          if yy_ch_buf (yy_bp) = ASCII.LF then
            Token_At_End_Of_Line := True;
          end if;
        end if;
-- END OF UMASS CODES.

<<do_action>>   -- this label is used only to access EOF actions
            case yy_act is
                when 0 =>  --  Must backtrack
                  --  Undo the effects of YY_DO_BEFORE_ACTION
                  yy_ch_buf(yy_cp) := yy_hold_char;
                  yy_cp := yy_last_accepting_cpos;
                  yy_current_state := yy_last_accepting_state;
                  goto next_action;


-- /* ... */ -style comments
  when 1 =>
--# line 53 "md5.l"

         MD5_Help.MD5_Comment(YYText(3..YYLength-2));
         

-- // -style comment -> skip rest of line.
  when 2 =>
--# line 58 "md5.l"

         MD5_Help.MD5_Comment(YYText);
                      linenum:= linenum + 1;
         

  when 3 =>
--# line 63 "md5.l"
 return BAR_t; 

  when 4 =>
--# line 64 "md5.l"
 return COMMA_t; 

  when 5 =>
--# line 65 "md5.l"
 return LBRACE_t; 

  when 6 =>
--# line 66 "md5.l"
 return RBRACE_t; 

  when 7 =>
--# line 67 "md5.l"
 return '('; 

  when 8 =>
--# line 68 "md5.l"
 return ')'; 

  when 9 =>
--# line 69 "md5.l"
 return C_INCLUDE_t; 

  when 10 =>
--# line 70 "md5.l"
 return NOT_t; 

-----------
-- Noise --
-----------
  when 11 =>
--# line 76 "md5.l"
 null;  -- skip rest of line - was  return C_CRAP_t; 

  when 12 =>
--# line 77 "md5.l"
 null; 

  when 13 =>
--# line 78 "md5.l"
 null; 

  when 14 =>
--# line 79 "md5.l"
 null; 

  when 15 =>
--# line 80 "md5.l"
 null; 

  when 16 =>
--# line 81 "md5.l"
 null; 

  when 17 =>
--# line 82 "md5.l"
 null; 

  when 18 =>
--# line 83 "md5.l"
 null; 

  when 19 =>
--# line 84 "md5.l"
 null; 

---------------
-- Resources --
---------------
  when 20 =>
--# line 90 "md5.l"
 return MD5Version_t; 

  when 21 =>
--# line 91 "md5.l"
 return commandline_t; 

--  Mesh file
  when 22 =>
--# line 94 "md5.l"
 return numJoints_t; 

  when 23 =>
--# line 95 "md5.l"
 return numMeshes_t; 

  when 24 =>
--# line 96 "md5.l"
 return joints_t; 

  when 25 =>
--# line 97 "md5.l"
 return mesh_t; 

  when 26 =>
--# line 98 "md5.l"
 return numverts_t; 

  when 27 =>
--# line 99 "md5.l"
 return shader_t; 

  when 28 =>
--# line 100 "md5.l"
 return vert_t; 

  when 29 =>
--# line 101 "md5.l"
 return numtris_t; 

  when 30 =>
--# line 102 "md5.l"
 return tri_t; 

  when 31 =>
--# line 103 "md5.l"
 return numweights_t; 

  when 32 =>
--# line 104 "md5.l"
 return weight_t; 

--  Anim file
  when 33 =>
--# line 107 "md5.l"
 return numFrames_t; 

  when 34 =>
--# line 108 "md5.l"
 return frameRate_t; 

  when 35 =>
--# line 109 "md5.l"
 return numAnimatedComponents_t; 

  when 36 =>
--# line 110 "md5.l"
 return hierarchy_t; 

  when 37 =>
--# line 111 "md5.l"
 return bounds_t; 

  when 38 =>
--# line 112 "md5.l"
 return baseframe_t; 

  when 39 =>
--# line 113 "md5.l"
 return frame_t; 

  when 40 =>
--# line 115 "md5.l"
 yylval.intval := 0; return NUMBER; 

  when 41 =>
--# line 116 "md5.l"
 yylval.intval := 1; return NUMBER; 

  when 42 =>
--# line 118 "md5.l"
 yylval.intval   := 0;
                   yylval.floatval := 0.0;
                   return NUMBER;
                 

  when 43 =>
--# line 123 "md5.l"
 begin
                     yylval.intval := Long_Long_Integer'Value(yytext);
                   exception
                     when Constraint_Error =>
                      -- declare
                      --   msg: constant String:=
                      --    "Error with integer ? [" & yytext & ']';
                      -- begin
                      --   Put_Line(Standard_Error, msg);
                      --   raise Constraint_Error with msg;
                      -- end;
                      yylval.intval := -1;
                      -- not nice at all, but a >2**31 number
                      -- seems to appear only at top (some checksum)
                   end;
                   yylval.floatval:= Long_Float( yylval.intval );
                   return NUMBER;

  when 44 =>
--# line 141 "md5.l"
 yylval.intval := Long_Long_Integer'Value("8#"&yytext&'#');
                   yylval.floatval:= Long_Float( yylval.intval );
                   return NUMBER;

  when 45 =>
--# line 145 "md5.l"

                   yylval.floatval := Long_Float'Value(yytext);
                   return FLOAT_t;
                   

  when 46 =>
--# line 150 "md5.l"
 declare
                     hexa_c: String:= yytext;
                     hexa_last: Integer:= hexa_c'Last;
                   begin
                     if hexa_c(hexa_last)='L' then
                       hexa_last:= hexa_last - 1;
                     end if;
                     yylval.intval := Long_Long_Integer'Value("16#" & hexa_c(hexa_c'First+2 .. hexa_last) & '#');
                     yylval.floatval:= Long_Float( yylval.intval );
                     return NUMBER;
                   end;
                

  when 47 =>
--# line 163 "md5.l"
return RCString; -- borrowed from ada95.l

-- Doesn't work with double quotes
-- \"({NOTGUIL})*\"    {return RCString;}
  when 48 =>
--# line 168 "md5.l"
return INCString;

  when 49 =>
--# line 170 "md5.l"
 return IDENT_t; 

  when 50 =>
--# line 173 "md5.l"
 null; -- \t  ;

  when 51 =>
--# line 174 "md5.l"
linenum:= linenum+1;

  when 52 =>
--# line 176 "md5.l"
 null; -- ??
                     -- C: return *yytext;
                   

-- "("                { return '('; }
-- ")"                { return ')'; }
-- "}"                { return '}'; }
-- "{"                { return '{'; }
  when 53 =>
--# line 184 "md5.l"
ECHO;
when YY_END_OF_BUFFER + INITIAL + 1 =>
    return End_Of_Input;
                when YY_END_OF_BUFFER =>
                    -- undo the effects of YY_DO_BEFORE_ACTION
                    yy_ch_buf(yy_cp) := yy_hold_char;

                    yytext_ptr := yy_bp;

                    case yy_get_next_buffer is
                        when EOB_ACT_END_OF_FILE =>
                            begin
                            if yyWrap then
                                -- note: because we've taken care in
                                -- yy_get_next_buffer() to have set up yytext,
                                -- we can now set up yy_c_buf_p so that if some
                                -- total hoser (like aflex itself) wants
                                -- to call the scanner after we return the
                                -- End_Of_Input, it'll still work - another
                                -- End_Of_Input will get returned.

                                yy_c_buf_p := yytext_ptr;

                                yy_act := YY_STATE_EOF((yy_start - 1) / 2);

                                goto do_action;
                            else
                                --  Start processing a new file
                                yy_init := True;
                                goto new_file;
                            end if;
                            end;
                        when EOB_ACT_RESTART_SCAN =>
                            yy_c_buf_p := yytext_ptr;
                            yy_hold_char := yy_ch_buf (yy_c_buf_p);
                        when EOB_ACT_LAST_MATCH =>
                            yy_c_buf_p := yy_n_chars;
                            yy_current_state := yy_get_previous_state;

                            yy_cp := yy_c_buf_p;
                            yy_bp := yytext_ptr;
                            goto next_action;
                        when others => null;
                        end case;  --  case yy_get_next_buffer()
                when others =>
                    Text_IO.Put ("action # ");
                    Text_IO.Put (Integer'Image (yy_act));
                    Text_IO.New_Line;
                    raise AFLEX_INTERNAL_ERROR;
            end case;  --  case (yy_act)
        end loop;  --  end of loop waiting for end of file
end YYLex;
--# line 184 "md5.l"
